



Alright âœ… â€” hereâ€™s the final CLI version of our URL validator/encoder tool with an optional --only-encode flag so you can use it in scripts or pipelines without the color table or analysis.

Python#!/usr/bin/env python3
import urllib.parse
import string
import sys

# RFC 3986 character sets
UNRESERVED = string.ascii_letters + string.digits + "-._~"
RESERVED = ":/?#[]@" + "!$&'()*+,;="

# ANSI colors
COLOR_RESET = "\033[0m"
COLOR_GREEN = "\033[92m"  # Unreserved
COLOR_YELLOW = "\033[93m" # Reserved
COLOR_RED = "\033[91m"    # Must Encode

def classify_char(c):
    """Classify a character according to RFC 3986 rules."""
    if c in UNRESERVED:
        return "Unreserved", COLOR_GREEN
    elif c in RESERVED:
        return "Reserved", COLOR_YELLOW
    else:
        return "Must Encode", COLOR_RED

def encode_custom_string(s):
    """Encodes a string for safe URL usage (UTF-8 percent-encoding)."""
    return urllib.parse.quote(s, safe=UNRESERVED + RESERVED)

def analyze_url(url):
    """Analyze each character in a URL and show encoding details with colors."""
    print(f"\nAnalyzing URL: {url}")
    print(f"{'Char':<6} {'Unicode':<10} {'Status':<15} {'UTF-8 Bytes':<20} {'Encoded'}")
    print("-" * 80)
    
    for c in url:
        status, color = classify_char(c) if ord(c) < 128 else ("Must Encode", COLOR_RED)
        utf8_bytes = " ".join(f"{b:02X}" for b in c.encode('utf-8'))
        encoded = urllib.parse.quote(c, safe=UNRESERVED + RESERVED)
        print(f"{color}{c!r:<6} U+{ord(c):04X}   {status:<15} {utf8_bytes:<20} {encoded}{COLOR_RESET}")

def highlight_url(url):
    """Return the URL string with unsafe/reserved characters highlighted in color."""
    highlighted = ""
    for c in url:
        _, color = classify_char(c) if ord(c) < 128 else ("Must Encode", COLOR_RED)
        highlighted += f"{color}{c}{COLOR_RESET}"
    return highlighted

def highlight_and_encode_url(url):
    """Highlight unsafe characters and replace them with encoded versions."""
    highlighted = ""
    transformed = ""
    for c in url:
        _, color = classify_char(c) if ord(c) < 128 else ("Must Encode", COLOR_RED)
        encoded = urllib.parse.quote(c, safe=UNRESERVED + RESERVED)
        highlighted += f"{color}{c}{COLOR_RESET}"
        transformed += encoded
    return highlighted, transformed

def validate_and_encode_url(url):
    """Validate and return a fully safe encoded URL."""
    parsed = urllib.parse.urlsplit(url)
    
    # Encode each part separately
    safe_scheme = parsed.scheme
    safe_netloc = parsed.netloc.encode("idna").decode("ascii")  # IDN support
    safe_path = encode_custom_string(parsed.path)
    safe_query = encode_custom_string(parsed.query)
    safe_fragment = encode_custom_string(parsed.fragment)
    
    safe_url = urllib.parse.urlunsplit((safe_scheme, safe_netloc, safe_path, safe_query, safe_fragment))
    return safe_url

def main():
    if len(sys.argv) < 2:
        print("Usage: python url_tool.py '<URL>' [--only-encode]")
        sys.exit(1)
    
    test_url = sys.argv[1]
    only_encode = "--only-encode" in sys.argv
    
    if only_encode:
        # Just output the safe encoded URL (no colors, no table)
        print(validate_and_encode_url(test_url))
        sys.exit(0)
    
    # Step 1: Highlight URL in context
    print("\nHighlighted URL in context:")
    print(highlight_url(test_url))
    
    # Step 2: Highlight + Auto Encode (before/after)
    highlighted, transformed = highlight_and_encode_url(test_url)
    print("\nHighlighted (before) and Auto-Encoded (after):")
    print("Before:", highlighted)
    print("After :", transformed)
    
    # Step 3: Detailed character analysis
    analyze_url(test_url)
    
    # Step 4: Fully safe encoded URL (RFC 3986 compliant)
    safe_url = validate_and_encode_url(test_url)
    print("\nSafe Encoded URL (RFC 3986 compliant):")
    print(safe_url)

if __name__ == "__main__":
    main()


How to Use
1. Normal Mode (Full Analysis)
Bashpython url_tool.py "https://exÃ¡mple.com/pa th/ðŸš€?q=cafÃ© &x=âœ“#frag ment"


Shows highlighted URL, before/after encoding, character table, and final safe URL.


2. Only Encode Mode (For Scripts)
Bashpython url_tool.py "https://exÃ¡mple.com/pa th/ðŸš€?q=cafÃ© &x=âœ“#frag ment" --only-encode

Output:
https://xn--exmple-cua.com/pa%20th/%F0%9F%9A%80?q=caf%C3%A9%20&x=%E2%9C%93#frag%20ment


No colors, no table â€” just the RFC 3986â€‘compliant encoded URL.


âœ… Now itâ€™s both a debugging tool and a scripting utility.
âœ… Works for ASCII, Unicode, emojis, and IDN domains.
âœ… Can be used interactively or in automation pipelines.

If you want, I can package this as a pipâ€‘installable commandâ€‘line tool so you can just run:
Bashurlcheck "https://example.com/ðŸš€ test"

from anywhere without python url_tool.py.
Do you want me to prepare that packaging setup?
