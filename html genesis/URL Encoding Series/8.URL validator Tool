





Alright ðŸš€ â€” hereâ€™s the final ultimate version of our URL validator/encoder tool.
Now it will:

Highlight unsafe characters in the original URL (color-coded).
Show a detailed table of each character.
Automatically replace unsafe characters with their percentâ€‘encoded form so you can see before/after in one view.


Pythonimport urllib.parse
import string

# RFC 3986 character sets
UNRESERVED = string.ascii_letters + string.digits + "-._~"
RESERVED = ":/?#[]@" + "!$&'()*+,;="

# ANSI colors
COLOR_RESET = "\033[0m"
COLOR_GREEN = "\033[92m"  # Unreserved
COLOR_YELLOW = "\033[93m" # Reserved
COLOR_RED = "\033[91m"    # Must Encode

def classify_char(c):
    """Classify a character according to RFC 3986 rules."""
    if c in UNRESERVED:
        return "Unreserved", COLOR_GREEN
    elif c in RESERVED:
        return "Reserved", COLOR_YELLOW
    else:
        return "Must Encode", COLOR_RED

def encode_custom_string(s):
    """Encodes a string for safe URL usage (UTF-8 percent-encoding)."""
    return urllib.parse.quote(s, safe=UNRESERVED + RESERVED)

def analyze_url(url):
    """Analyze each character in a URL and show encoding details with colors."""
    print(f"\nAnalyzing URL: {url}")
    print(f"{'Char':<6} {'Unicode':<10} {'Status':<15} {'UTF-8 Bytes':<20} {'Encoded'}")
    print("-" * 80)
    
    for c in url:
        status, color = classify_char(c) if ord(c) < 128 else ("Must Encode", COLOR_RED)
        utf8_bytes = " ".join(f"{b:02X}" for b in c.encode('utf-8'))
        encoded = urllib.parse.quote(c, safe=UNRESERVED + RESERVED)
        print(f"{color}{c!r:<6} U+{ord(c):04X}   {status:<15} {utf8_bytes:<20} {encoded}{COLOR_RESET}")

def highlight_url(url):
    """Return the URL string with unsafe/reserved characters highlighted in color."""
    highlighted = ""
    for c in url:
        _, color = classify_char(c) if ord(c) < 128 else ("Must Encode", COLOR_RED)
        highlighted += f"{color}{c}{COLOR_RESET}"
    return highlighted

def highlight_and_encode_url(url):
    """Highlight unsafe characters and replace them with encoded versions."""
    highlighted = ""
    transformed = ""
    for c in url:
        status, color = classify_char(c) if ord(c) < 128 else ("Must Encode", COLOR_RED)
        encoded = urllib.parse.quote(c, safe=UNRESERVED + RESERVED)
        highlighted += f"{color}{c}{COLOR_RESET}"
        transformed += encoded
    return highlighted, transformed

def validate_and_encode_url(url):
    """Validate and return a fully safe encoded URL."""
    parsed = urllib.parse.urlsplit(url)
    
    # Encode each part separately
    safe_scheme = parsed.scheme
    safe_netloc = parsed.netloc.encode("idna").decode("ascii")  # IDN support
    safe_path = encode_custom_string(parsed.path)
    safe_query = encode_custom_string(parsed.query)
    safe_fragment = encode_custom_string(parsed.fragment)
    
    safe_url = urllib.parse.urlunsplit((safe_scheme, safe_netloc, safe_path, safe_query, safe_fragment))
    return safe_url

if __name__ == "__main__":
    # Example URL with unsafe characters
    test_url = "https://exÃ¡mple.com/pa th/ðŸš€?q=cafÃ© &x=âœ“#frag ment"
    
    # Step 1: Highlight URL in context
    print("\nHighlighted URL in context:")
    print(highlight_url(test_url))
    
    # Step 2: Highlight + Auto Encode (before/after)
    highlighted, transformed = highlight_and_encode_url(test_url)
    print("\nHighlighted (before) and Auto-Encoded (after):")
    print("Before:", highlighted)
    print("After :", transformed)
    
    # Step 3: Detailed character analysis
    analyze_url(test_url)
    
    # Step 4: Fully safe encoded URL (RFC 3986 compliant)
    safe_url = validate_and_encode_url(test_url)
    print("\nSafe Encoded URL (RFC 3986 compliant):")
    print(safe_url)


New Feature: Autoâ€‘Encoding in Context
The function highlight_and_encode_url now:

Shows the original URL with colors (green = safe, yellow = reserved, red = must encode).
Produces a fully encoded version of the same URL inline.


Example Output in Terminal
Highlighted URL in context:
https://exÃ¡mple.com/pa th/ðŸš€?q=cafÃ© &x=âœ“#frag ment

Highlighted (before) and Auto-Encoded (after):
Before: https://exÃ¡mple.com/pa th/ðŸš€?q=cafÃ© &x=âœ“#frag ment
After : https://ex%C3%A1mple.com/pa%20th/%F0%9F%9A%80?q=caf%C3%A9%20&x=%E2%9C%93#frag%20ment

Analyzing URL: https://exÃ¡mple.com/pa th/ðŸš€?q=cafÃ© &x=âœ“#frag ment
...
Safe Encoded URL (RFC 3986 compliant):
https://xn--exmple-cua.com/pa%20th/%F0%9F%9A%80?q=caf%C3%A9%20&x=%E2%9C%93#frag%20ment


âœ… Now you get:

Visual scan of unsafe characters.
Before/after transformation in one glance.
Detailed breakdown for debugging.
RFC 3986â€‘compliant safe URL.


If you want, I can turn this into a CLI tool so you can run:
Bashpython url_tool.py "https://example.com/ðŸš€ test"

and instantly get the highlighted + encoded output in your terminal.
Do you want me to make it a CLI tool next?
