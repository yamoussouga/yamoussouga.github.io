



Perfect âœ… â€” letâ€™s add a --json flag so our urlcheck CLI can output structured JSON instead of colored text.
This is great for automation, API pipelines, or integrating into other tools.

Updated cli.py with JSON Output Support
Python#!/usr/bin/env python3
import urllib.parse
import string
import sys
import json

# RFC 3986 character sets
UNRESERVED = string.ascii_letters + string.digits + "-._~"
RESERVED = ":/?#[]@" + "!$&'()*+,;="

# ANSI colors
COLOR_RESET = "\033[0m"
COLOR_GREEN = "\033[92m"  # Unreserved
COLOR_YELLOW = "\033[93m" # Reserved
COLOR_RED = "\033[91m"    # Must Encode

def classify_char(c):
    """Classify a character according to RFC 3986 rules."""
    if c in UNRESERVED:
        return "Unreserved", COLOR_GREEN
    elif c in RESERVED:
        return "Reserved", COLOR_YELLOW
    else:
        return "Must Encode", COLOR_RED

def encode_custom_string(s):
    """Encodes a string for safe URL usage (UTF-8 percent-encoding)."""
    return urllib.parse.quote(s, safe=UNRESERVED + RESERVED)

def analyze_url(url):
    """Return a list of character analysis dictionaries."""
    analysis = []
    for c in url:
        status, _ = classify_char(c) if ord(c) < 128 else ("Must Encode", COLOR_RED)
        utf8_bytes = [f"{b:02X}" for b in c.encode('utf-8')]
        encoded = urllib.parse.quote(c, safe=UNRESERVED + RESERVED)
        analysis.append({
            "char": c,
            "unicode": f"U+{ord(c):04X}",
            "status": status,
            "utf8_bytes": utf8_bytes,
            "encoded": encoded
        })
    return analysis

def highlight_url(url):
    """Return the URL string with unsafe/reserved characters highlighted in color."""
    return "".join(
        f"{classify_char(c)[1] if ord(c) < 128 else COLOR_RED}{c}{COLOR_RESET}"
        for c in url
    )

def highlight_and_encode_url(url):
    """Highlight unsafe characters and replace them with encoded versions."""
    highlighted = ""
    transformed = ""
    for c in url:
        _, color = classify_char(c) if ord(c) < 128 else ("Must Encode", COLOR_RED)
        encoded = urllib.parse.quote(c, safe=UNRESERVED + RESERVED)
        highlighted += f"{color}{c}{COLOR_RESET}"
        transformed += encoded
    return highlighted, transformed

def validate_and_encode_url(url):
    """Validate and return a fully safe encoded URL."""
    parsed = urllib.parse.urlsplit(url)
    safe_scheme = parsed.scheme
    safe_netloc = parsed.netloc.encode("idna").decode("ascii")  # IDN support
    safe_path = encode_custom_string(parsed.path)
    safe_query = encode_custom_string(parsed.query)
    safe_fragment = encode_custom_string(parsed.fragment)
    return urllib.parse.urlunsplit((safe_scheme, safe_netloc, safe_path, safe_query, safe_fragment))

def main():
    if len(sys.argv) < 2:
        print("Usage: urlcheck '<URL>' [--only-encode] [--json]")
        sys.exit(1)

    test_url = sys.argv[1]
    only_encode = "--only-encode" in sys.argv
    json_output = "--json" in sys.argv

    if only_encode and not json_output:
        # Just output the safe encoded URL (no colors, no table)
        print(validate_and_encode_url(test_url))
        sys.exit(0)

    if json_output:
        # Output structured JSON
        result = {
            "original_url": test_url,
            "safe_encoded_url": validate_and_encode_url(test_url),
            "analysis": analyze_url(test_url)
        }
        print(json.dumps(result, indent=2, ensure_ascii=False))
        sys.exit(0)

    # Normal interactive mode
    print("\nHighlighted URL in context:")
    print(highlight_url(test_url))

    highlighted, transformed = highlight_and_encode_url(test_url)
    print("\nHighlighted (before) and Auto-Encoded (after):")
    print("Before:", highlighted)
    print("After :", transformed)

    print("\nCharacter Analysis Table:")
    print(f"{'Char':<6} {'Unicode':<10} {'Status':<15} {'UTF-8 Bytes':<20} {'Encoded'}")
    print("-" * 80)
    for entry in analyze_url(test_url):
        status, color = classify_char(entry["char"]) if ord(entry["char"]) < 128 else ("Must Encode", COLOR_RED)
        print(f"{color}{entry['char']!r:<6} {entry['unicode']:<10} {status:<15} "
              f"{' '.join(entry['utf8_bytes']):<20} {entry['encoded']}{COLOR_RESET}")

    print("\nSafe Encoded URL (RFC 3986 compliant):")
    print(validate_and_encode_url(test_url))

if __name__ == "__main__":
    main()


How to Use the JSON Mode
1. JSON Output
Bashurlcheck "https://exÃ¡mple.com/pa th/ðŸš€?q=cafÃ© &x=âœ“#frag ment" --json

Example Output:
Json{
  "original_url": "https://exÃ¡mple.com/pa th/ðŸš€?q=cafÃ© &x=âœ“#frag ment",
  "safe_encoded_url": "https://xn--exmple-cua.com/pa%20th/%F0%9F%9A%80?q=caf%C3%A9%20&x=%E2%9C%93#frag%20ment",
  "analysis": [
    {
      "char": "h",
      "unicode": "U+0068",
      "status": "Unreserved",
      "utf8_bytes": ["68"],
      "encoded": "h"
    },
    {
      "char": "Ã©",
      "unicode": "U+00E9",
      "status": "Must Encode",
      "utf8_bytes": ["C3", "A9"],
      "encoded": "%C3%A9"
    }
    // ...
  ]
}


2. Only Encode Mode
Bashurlcheck "https://exÃ¡mple.com/pa th/ðŸš€?q=cafÃ© &x=âœ“#frag ment" --only-encode

Outputs:
https://xn--exmple-cua.com/pa%20th/%F0%9F%9A%80?q=caf%C3%A9%20&x=%E2%9C%93#frag%20ment


3. Normal Mode
Bashurlcheck "https://exÃ¡mple.com/pa th/ðŸš€?q=cafÃ© &x=âœ“#frag ment"


Colorâ€‘highlighted URL
Before/after encoding
Character analysis table
Final safe encoded URL


âœ… Now urlcheck can be used:

Interactively (color mode)
In scripts (--only-encode)
In automation pipelines (--json)


If you want, I can now **add a `--decode
